{"title":"Query.apex","githubRepo":"Click-to-Cloud/Query.apex","googleAnalytics":"","index":{"title":"Home","description":"Query.apex provides a flexible and dynamic way of building a SOQL query on the Salesforce platform.","content":" Function Chaining Query.apex supports declarative style function chaining Friendliness Query.apex aims enhance the productivity of the development by providing friendly APIs Complex Condition Support Query.apex allows complex condition in a functional style ","srcFilePath":"src/pages/index.soy","id":"pages","location":"/./","url":"/query-apex/./","children":{"docs":{"title":"Docs","description":"Everything you need to know to get started.","content":" Docs Start learning how to leverage the power of . Choose a Guide Each one provide step by step coverage for every core feature. ","srcFilePath":"src/pages/docs/index.soy","id":"docs","location":"/docs/","url":"/query-apex/docs/","children":{"search":{"title":"Search","description":"Find what you're looking for in the documentation.","hidden":true,"content":" Electric Docs Start learning how to leverage the power of . ","srcFilePath":"src/pages/docs/search.soy","id":"search","location":"/docs/search.html","url":"/query-apex/docs/search.html"},"Query":{"children":{"aggregate":{"title":"Aggregate Functions","description":"Aggregate Functions in Query","layout":"guide","icon":"code-file","weight":6,"content":" {$page.description} This section describes methods related to aggregate functions. When using any of these methods, you can only get the result using the aggregate() method in the end. count Apply COUNT() function to a field. public Query count(String field) field: API name of the field. Can also be a field of a parent, e.g. 'Owner.Name'. new Query('Account'). count('Id'); public Query count(String field, String alias) field: API name of the field. Can also be a field of a parent, e.g. 'Owner.Name'. alias: The alias set to the aggregate function. new Query('Account'). count('Id', 'idCount'); countDistinct Apply COUNT_DISTINCT() function to a field. public Query countDistinct(String field) field: API name of the field. Can also be a field of a parent, e.g. 'Owner.Name'. new Query('Account'). countDistinct('Id'); public Query countDistinct(String field, String alias) field: API name of the field. Can also be a field of a parent, e.g. 'Owner.Name'. alias: The alias set to the aggregate function. new Query('Account'). countDistinct('Id', 'idCount'); max Apply MAX() function to a field public Query max(String field) field: API name of the field. Can also be a field of a parent, e.g. 'Owner.Name'. new Query('Account'). max('Id'); public Query max(String field, String alias) field: API name of the field. Can also be a field of a parent, e.g. 'Owner.Name'. alias: The alias set to the aggregate function. new Query('Account'). max('NumberOfEmployees', 'maxEmployees'); min Apply MIN() function to a field public Query min(String field) field: API name of the field. Can also be a field of a parent, e.g. 'Owner.Name'. new Query('Account'). min('Id'); public Query min(String field, String alias) field: API name of the field. Can also be a field of a parent, e.g. 'Owner.Name'. alias: The alias set to the aggregate function. new Query('Account'). min('NumberOfEmployees', 'minEmployees'); avg Apply AVG() function to a field public Query avg(String field) field: API name of the field. Can also be a field of a parent, e.g. 'Owner.Name'. new Query('Account'). avg('Id'); public Query avg(String field, String alias) field: API name of the field. Can also be a field of a parent, e.g. 'Owner.Name'. alias: The alias set to the aggregate function. new Query('Account'). avg('NumberOfEmployees', 'avgEmployees'); sum Apply SUM() function to a field public Query sum(String field) field: API name of the field. Can also be a field of a parent, e.g. 'Owner.Name'. new Query('Account'). sum('Id'); public Query sum(String field, String alias) field: API name of the field. Can also be a field of a parent, e.g. 'Owner.Name'. alias: The alias set to the aggregate function. new Query('Account'). sum('NumberOfEmployees', 'sumEmployees'); groupBy Add the field to the GROUP BY clause. public Query groupBy(String fields) field: API name of the field, or multiple field names separated by ','. new Query('Account'). groupBy('Name'). groupBy('OwnerId, CreatedById'); public Query groupBy(Set\\ fieldSet) field: A set of fields. new Query('Account'). groupBy(new Set{'Name', 'CreatedById'}); selectField Select a specific field and set an alias to it. This method is only available when using aggregate functions. public Query selectField(String field, String alias) field: API name of the field. Can also be a field of a parent, e.g. 'Owner.Name'. alias: Name of the alias. Query query = new Query('Account'). selectField('Name', 'myName'). groupBy('Name'); public Query selectField(Schema.SObjectField field, String alias) field: A Schema.SObjectField. alias: Name of the alias. Query query = new Query(Account.getSObjectType()). selectField(Account.Name, 'myName'). groupBy('Name'); addHaving Add a HAVING clause as conditions of the aggregated query. public Query addHaving(Condition condition) condition: A Query.Condition. new Query('Account'). count('Name', 'countName'). groupBy('Rating'). addHaving(Query.conditionGe('Count(Name)', 2)); aggregate Get the result of the aggregated query. Can only be used with aggregate functions. public List\\ aggregate() Get the result of the aggregated query. The returned list is guaranteed to be non-empty. new Query('Account'). count('Name'). aggregate(); ","srcFilePath":"src/pages/docs/Query/aggregate.md","id":"aggregate","location":"/docs/Query/aggregate.html","url":"/query-apex/docs/Query/aggregate.html"},"condition":{"title":"Condition","description":"Condition methods in Query","layout":"guide","icon":"code-file","weight":4,"content":" {$page.description} byId Add a condition to the query, filtering the result by a specific ID or a collection of ID. Alias to addConditionEq('Id', ...) public Query byId(Id id) id: The specified ID of the SObject Query query = new Query('Account'). byId(); public Query byId(List\\ idList) idList: A List of specified IDs Query query = new Query('Account'). byId(new List{'001O000000qkv3KIAQ'}); public Query byId(Set\\ idSet) idSet: A Set of specified IDs Query query = new Query('Account'). byId(new Set{'001O000000qkv3KIAQ'}); lookup Add a condition to the query, filtering the result by a foreign key. public Query lookup(String fieldName, Id id) fieldName: The lookup field name id: The Id to filter the lookup field Query query = new Query('Contact'). lookup('AccountId', '001O000000qkv3KIAQ'); public Query lookup(String fieldName, List\\ idList) fieldName: The lookup field name idList: The list of Id to filter the lookup field Query query = new Query('Contact'). lookup('AccountId', new List{'001O000000qkv3KIAQ'}); public Query lookup(String fieldName, Set\\ idSet) fieldName: The lookup field name idSet: The Set of Id to filter the lookup field Query query = new Query('Contact'). lookup('AccountId', new Set{'001O000000qkv3KIAQ'}); public Query lookup(String fieldName, SObject sobj) fieldName: The lookup field name sobj: The SObject record, whose Id will be taken to filter the lookup field Query query = new Query('Contact'). lookup('AccountId', new Account(Id = '001O000000qkv3KIAQ')); public Query lookup(String fieldName, List\\ sObjectList) fieldName: The lookup field name sObjectList: The list of SObject records, whose Id will be taken to filter the lookup field Query query = new Query('Contact'). lookup('AccountId', new List{new Account(Id = '001O000000qkv3KIAQ')}); addConditionXX Add a condition to the query, limiting the sObject. 'XX' can be one of these comparison operators: Eq, NotEq, In, Lt, Le, Gt, Ge, Like. By default, all the conditions added by this method will be joined by the boolean operator 'and', i.e. the result is true if and only if all the conditions are true, unless calling the switchToDisjunction method. public Query addConditionEq(String lhs, Object rhs) Add a condition lhs = rhs. The result is true if and only if the left hand side value equals to the right hand side value. lhs: Left hand side of the binary expression, which can only be a field name. rhs: Right hand side of the binary expression, which can only be a primitive type or a Query.Literal. Query query = new Query('Account'). addConditionEq('Id', '001O000000qkv3KIAQ'); public Query addConditionNotEq(String lhs, Object rhs) Add a condition lhs != rhs. The result is true if and only if the left hand side value does not equal to the right hand side value. lhs: Left hand side of the binary expression, which can only be a field name. rhs: Right hand side of the binary expression, which can only be a primitive type or a Query.Literal. Query query = new Query('Account'). addConditionNotEq('Id', '001O000000qkv3KIAQ'); public Query addConditionIn(String lhs, Object rhs) Add a condition lhs IN rhs. The result is true if and only if the left hand side value equals to any value in the right hand side collection. lhs: Left hand side of the binary expression, which can only be a field name. rhs: Right hand side of the binary expression, which can only be a List or a Set. Query query = new Query('Account'). addConditionIn('Id', new Set{'001O000000qkv3KIAQ'}); public Query addConditionNotIn(String lhs, Object rhs) Add a condition lhs NOT IN rhs. The result is true if and only if the left hand side value does not equal to any value in the right hand side collection. lhs: Left hand side of the binary expression, which can only be a field name. rhs: Right hand side of the binary expression, which can only be a List or a Set. Query query = new Query('Account'). addConditionNotIn('Id', new Set{'001O000000qkv3KIAQ'}); public Query addConditionLt(String lhs, Object rhs) Add a condition lhs < rhs. The result is true if and only if the left hand side value is less than the right hand side value. lhs: Left hand side of the binary expression, which can only be a field name. rhs: Right hand side of the binary expression, which can only be a primitive type or a Query.Literal. Query query = new Query('Account'). addConditionLt('NumberOfEmployees', 10); public Query addConditionLe(String lhs, Object rhs) Add a condition lhs rhs. The result is true if and only if the left hand side value is greater than the right hand side value. lhs: Left hand side of the binary expression, which can only be a field name. rhs: Right hand side of the binary expression, which can only be a primitive type or a Query.Literal. Query query = new Query('Account'). addConditionGt('NumberOfEmployees', 10); public Query addConditionGe(String lhs, Object rhs) Add a condition lhs = rhs. The result is true if and only if the left hand side value is greater than, or equals the right hand side value. lhs: Left hand side of the binary expression, which can only be a field name. rhs: Right hand side of the binary expression, which can only be a primitive type or a Query.Literal. Query query = new Query('Account'). addConditionGe('NumberOfEmployees', 10); public Query addConditionLike(String lhs, Object rhs) Add a condition lhs LIKE rhs. The result is true if and only if the left hand side value matches the right hand side value, in a way similar to the LIKE operator in SQL. lhs: Left hand side of the binary expression, which can only be a field name. rhs: Right hand side of the binary expression, which can only be a String. Query query = new Query('Account'). addConditionLike('Name', '%Sam%'); addCondition public Query addCondition(Condition condition) Add a condition expression, which is a Query.Condition type instance. condition: A Query.Condition type, which can be constructed by a static conditionXX method. Query q = new Query('Account'). addCondition(Query.conditionEq('Name', 'Sam')); conditionXX Creates a Query.Condition instance. 'XX' can be one of these comparison operators: Eq, NotEq, In, Lt, Le, Gt, Ge, Like. public static Condition conditionEq(String lhs, Object rhs) Creates a condition lhs = rhs. The result is true if and only if the left hand side value equals to the right hand side value. lhs: Left hand side of the binary expression, which can only be a field name. rhs: Right hand side of the binary expression, which can only be a primitive type or a Query.Literal. Query.Condition condition = Query.conditionEq('Name', 'Sam'); Query q = new Query('Account'). addCondition(condition); public static Condition conditionNotEq(String lhs, Object rhs) Creates a condition lhs != rhs. The result is true if and only if the left hand side value does not equal to the right hand side value. lhs: Left hand side of the binary expression, which can only be a field name. rhs: Right hand side of the binary expression, which can only be a primitive type or a Query.Literal. Query.Condition condition = Query.conditionNotEq('Name', 'Sam'); Query q = new Query('Account'). addCondition(condition); public static Condition conditionIn(String lhs, Object rhs) Creates a condition lhs IN rhs. The result is true if and only if the left hand side value equals to any value in the right hand side collection. lhs: Left hand side of the binary expression, which can only be a field name. rhs: Right hand side of the binary expression, which can only be a List or a Set. Query.Condition condition = Query.conditionIn('Name', new Set{'Sam'}); Query q = new Query('Account'). addCondition(condition); public static Condition conditionNotIn(String lhs, Object rhs) Creates a condition lhs NOT IN rhs. The result is true if and only if the left hand side value does not equal to any value in the right hand side collection. lhs: Left hand side of the binary expression, which can only be a field name. rhs: Right hand side of the binary expression, which can only be a List or a Set. Query.Condition condition = Query.conditionNotIn('Name', new Set{'Sam'}); Query q = new Query('Account'). addCondition(condition); public static Condition conditionLt(String lhs, Object rhs) Creates a condition lhs < rhs. The result is true if and only if the left hand side value is less than the right hand side value. lhs: Left hand side of the binary expression, which can only be a field name. rhs: Right hand side of the binary expression, which can only be a primitive type or a Query.Literal. Query.Condition condition = Query.conditionLt('NumberOfEmployees', 10); Query q = new Query('Account'). addCondition(condition); public static Condition conditionLe(String lhs, Object rhs) Creates a condition lhs rhs. The result is true if and only if the left hand side value is greater than the right hand side value. lhs: Left hand side of the binary expression, which can only be a field name. rhs: Right hand side of the binary expression, which can only be a primitive type or a Query.Literal. Query.Condition condition = Query.conditionGt('NumberOfEmployees', 10); Query q = new Query('Account'). addCondition(condition); public static Condition conditionGe(String lhs, Object rhs) Creates a condition lhs = rhs. The result is true if and only if the left hand side value is greater than, or equals the right hand side value. lhs: Left hand side of the binary expression, which can only be a field name. rhs: Right hand side of the binary expression, which can only be a primitive type or a Query.Literal. Query.Condition condition = Query.conditionGe('NumberOfEmployees', 10); Query q = new Query('Account'). addCondition(condition); public static Condition conditionLike(String lhs, Object rhs) Creates a condition lhs LIKE rhs. The result is true if and only if the left hand side value matches the right hand side value, in a way similar to the LIKE operator in SQL. lhs: Left hand side of the binary expression, which can only be a field name. rhs: Right hand side of the binary expression, which can only be a String. Query.Condition condition = Query.conditionLike('Name', '%Sam%'); Query q = new Query('Account'). addCondition(condition); doAnd Join two or more Query.Condition instances with boolean operator 'and'. The result is true if and only if all the conditions are true. Because and has been a reserved keyword in Apex, we have to rename the method to doAnd. public static Condition doAnd(Condition lhs, Condition rhs) lhs: Left hand side of the boolean expression rhs: Right hand side of the boolean expression The result is true if and only if both lhs and rhs are true. Query.Condition condition = Query.doAnd( Query.conditionLike('Name', '%Sam%'), Query.conditionGe('NumberOfEmployees', 10) ); Query q = new Query('Account'). addCondition(condition); public static Condition doAnd(Condition condition0, Condition condition1, Condition condition2) condition0: First condition in the boolean expression condition1: Second condition in the boolean expression condition2: Third condition in the boolean expression The result is true if and only if all three condtions are true. Query.Condition condition = Query.doAnd( Query.conditionLike('Name', '%Sam%'), Query.conditionEq('Phone', '123 456 789'), Query.conditionGe('NumberOfEmployees', 10) ); Query q = new Query('Account'). addCondition(condition); public static Condition doAnd(Condition condition0, Condition condition1, Condition condition2, Condition condition3) condition0: First condition in the boolean expression condition1: Second condition in the boolean expression condition2: Third condition in the boolean expression condition3: Fourth condition in the boolean expression The result is true if and only if all four condtions are true. Query.Condition condition = Query.doAnd( Query.conditionLike('Name', '%Sam%'), Query.conditionEq('Phone', '123 456 789'), Query.conditionIn('Id', new Set{'00190000012KXI2AAO'}), Query.conditionGe('NumberOfEmployees', 10) ); Query q = new Query('Account'). addCondition(condition); public static Condition doAnd(List\\ conditions) conditions: A list of conditions in the boolean expression The result is true if and only if all the conditions in the list are true. List conditions = new List{ Query.conditionLike('Name', '%Sam%'), Query.conditionEq('Phone', '123 456 789'), Query.conditionIn('Id', new Set{'00190000012KXI2AAO'}), Query.conditionGe('NumberOfEmployees', 10) }; Query.Condition condition = Query.doAnd(conditions); Query q = new Query('Account'). addCondition(condition); doOr Join two or more Query.Condition instances with boolean operator 'or'. The result is true if and only if at least one of the conditions is true. Because or has been a reserved keyword in Apex, we have to rename the method to doOr. public static Condition doOr(Condition lhs, Condition rhs) lhs: Left hand side of the boolean expression rhs: Right hand side of the boolean expression The result is true if and only if either lhs or rhs is true. Query.Condition condition = Query.doOr( Query.conditionLike('Name', '%Sam%'), Query.conditionGe('NumberOfEmployees', 10) ); Query q = new Query('Account'). addCondition(condition); public static Condition doOr(Condition condition0, Condition condition1, Condition condition2) condition0: First condition in the boolean expression condition1: Second condition in the boolean expression condition2: Third condition in the boolean expression The result is true if and only if at least one of the three conditions is true. Query.Condition condition = Query.doOr( Query.conditionLike('Name', '%Sam%'), Query.conditionEq('Phone', '123 456 789'), Query.conditionGe('NumberOfEmployees', 10) ); Query q = new Query('Account'). addCondition(condition); public static Condition doAnd(Condition condition0, Condition condition1, Condition condition2, Condition condition3) condition0: First condition in the boolean expression condition1: Second condition in the boolean expression condition2: Third condition in the boolean expression condition3: Fourth condition in the boolean expression The result is true if and only if at least one of the four conditions is true. Query.Condition condition = Query.doOr( Query.conditionLike('Name', '%Sam%'), Query.conditionEq('Phone', '123 456 789'), Query.conditionIn('Id', new Set{'00190000012KXI2AAO'}), Query.conditionGe('NumberOfEmployees', 10) ); Query q = new Query('Account'). addCondition(condition); public static Condition doAnd(List\\ conditions) conditions: A list of conditions in the boolean expression The result is true if and only if at least one condition in the list is true. List conditions = new List{ Query.conditionLike('Name', '%Sam%'), Query.conditionEq('Phone', '123 456 789'), Query.conditionIn('Id', new Set{'00190000012KXI2AAO'}), Query.conditionGe('NumberOfEmployees', 10) }; Query.Condition condition = Query.doOr(conditions); Query q = new Query('Account'). addCondition(condition); Misc public Query switchToDisjunction() After calling this function, all expression added by addCondition or addConditionXX will be joined with the boolean or operator, i.e. the query condition is true if and only if at least one of these expression are true. Query q = new Query('Account'). addCondition(Query.doAnd( Query.conditionEq('Name', 'Jack'), Query.conditionEq('Phone', '123 456 789') )). addConditionEq('Name', 'David'). switchToDisjunction(); The example above is equivalent to this query: SELECT Id FROM Account WHERE (Name = 'Jack' AND Phone = '123 456 789) OR (Name = 'David') public Query switchToConjunction() Reverse the effect of switchToDisjunction. After calling this function, all expression added by addCondition or addConditionXX will be joined with the boolean and operator, i.e. the query condition is true if and only if all these expression are true. Query q = new Query('Account'). addCondition(Query.doOr( Query.conditionEq('Name', 'Jack'), Query.conditionEq('Phone', '123 456 789') )). addConditionEq('Name', 'David'). switchToDisjunction(). switchToConjunction(); The example above is equivalent to this query: SELECT Id FROM Account WHERE (Name = 'Jack' OR Phone = '123 456 789) AND (Name = 'David') public Query resetCondition() Clear all conditions. Query q = new Query('Account'). addConditionEq('Name', 'David'). resetCondition(); Date Literals The second parameter of the addConditionXX and conditionXX methods is usually a binding variable, but in some cases, we can use date literals to build date or date time related conditions more easily. Query q = new Query('Account'). addConditionLe('LastModifiedDate', Query.TODAY). addConditionEq('CreatedDate', Query.LAST_N_WEEKS(3)); The predefined Date Literals includes ones with no parameters, and some with an Integer as a parameter. public static final DateLiteral YESTERDAY public static final DateLiteral TODAY public static final DateLiteral TOMORROW public static final DateLiteral LAST\\_WEEK public static final DateLiteral THIS\\_WEEK public static final DateLiteral NEXT\\_WEEK public static final DateLiteral LAST\\_MONTH public static final DateLiteral THIS\\_MONTH public static final DateLiteral NEXT\\_MONTH public static final DateLiteral LAST\\90\\DAYS public static final DateLiteral NEXT\\90\\DAYS public static final DateLiteral THIS\\_QUARTER public static final DateLiteral LAST\\_QUARTER public static final DateLiteral NEXT\\_QUARTER public static final DateLiteral THIS\\_YEAR public static final DateLiteral LAST\\_YEAR public static final DateLiteral NEXT\\_YEAR public static final DateLiteral THIS\\FISCAL\\QUARTER public static final DateLiteral LAST\\FISCAL\\QUARTER public static final DateLiteral NEXT\\FISCAL\\QUARTER public static final DateLiteral THIS\\FISCAL\\YEAR public static final DateLiteral LAST\\FISCAL\\YEAR public static final DateLiteral NEXT\\FISCAL\\YEAR public static DateLiteral LAST\\N\\DAYS(Integer n) public static DateLiteral NEXT\\N\\DAYS(Integer n) public static DateLiteral LAST\\N\\WEEKS(Integer n) public static DateLiteral NEXT\\N\\WEEKS(Integer n) public static DateLiteral LAST\\N\\MONTHS(Integer n) public static DateLiteral NEXT\\N\\MONTHS(Integer n) public static DateLiteral LAST\\N\\QUARTERS(Integer n) public static DateLiteral NEXT\\N\\QUARTERS(Integer n) public static DateLiteral LAST\\N\\YEARS(Integer n) public static DateLiteral NEXT\\N\\YEARS(Integer n) public static DateLiteral LAST\\N\\FISCAL\\_QUARTERS(Integer n) public static DateLiteral NEXT\\N\\FISCAL\\_QUARTERS(Integer n) public static DateLiteral LAST\\N\\FISCAL\\_YEARS(Integer n) public static DateLiteral NEXT\\N\\FISCAL\\_YEARS(Integer n) ","srcFilePath":"src/pages/docs/Query/condition.md","id":"condition","location":"/docs/Query/condition.html","url":"/query-apex/docs/Query/condition.html"},"constructors":{"title":"Constructor","description":"Constructors of Query","layout":"guide","icon":"code-file","weight":1,"content":" {$page.description} Constructor Creates a new Query instance. public Query(String objectName) objectName: Name of the expected object. Query query = new Query('Account'); public Query(Schema.SObjectType objectType) objectType: An schema SObject type Query query = new Query(Account.getSObjectType()); ","srcFilePath":"src/pages/docs/Query/constructors.md","id":"constructors","location":"/docs/Query/constructors.html","url":"/query-apex/docs/Query/constructors.html"},"field":{"title":"Field Selection","description":"Field selection methods in Query","layout":"guide","icon":"code-file","weight":3,"content":" {$page.description} selectField public Query selectField(String field) Select a specific field. field: API name of the field. Can also be a field of a parent, e.g. 'Owner.Name'. Query query = new Query('Account'). selectField('Name'). selectField('Owner.Name'); public Query selectField(Schema.SObjectField field) Select a specific field. field: A Schema.SObjectField. Query query = new Query(Account.getSObjectType()). selectField(Account.Name). selectField(Account.OwnerId); public Query selectField(String field, String alias) Select a specific field and set an alias to it. This method is only available when using aggregate functions. field: API name of the field. Can also be a field of a parent, e.g. 'Owner.Name'. alias: Name of the alias. Query query = new Query('Account'). selectField('Name', 'myName'). groupBy('Name'); public Query selectField(Schema.SObjectField field, String alias) Select a specific field and set an alias to it. This method is only available when using aggregate functions. field: A Schema.SObjectField. alias: Name of the alias. Query query = new Query(Account.getSObjectType()). selectField(Account.Name, 'myName'). groupBy('Name'); selectFields Select specific fields. public Query selectFields(String field) field: API name of the field, or multiple field names separated by ','. Query query = new Query('Account'). selectFields('Name'). selectFields('OwnerId, CreatedById'); public Query selectFields(List\\ fieldList) fieldList: A list of field API names. Query query = new Query('Account'). selectFields(new List{'OwnerId', 'CreatedById'}); public Query selectFields(Set\\ fieldSet) fieldSet: A Set of field API names. Query query = new Query('Account'). selectFields(new Set{'OwnerId', 'CreatedById'}); public Query selectFields(Schema.SObjectField field) Alias of selectField(Schema.SObjectField field) field: A Schema.SObjectField Query query = new Query(Account.getSObjectType()). selectField(Account.Name). selectField(Account.OwnerId); public Query selectFields(Set\\ fields) fields: A Set of Schema.SObjectField Query query = new Query(Account.getSObjectType()). selectFields(new Set{Account.Name, Account.OwnerId}); public Query selectFields(List\\ fields) fields: A List of Schema.SObjectField Query query = new Query(Account.getSObjectType()). selectFields(new List{Account.Name, Account.OwnerId}); selectAllFields public Query selectAllFields() Select all accessible fields in the current object Query query = new Query('Account'). selectAllFields(); public Query selectAllFields(String parentField) Select all accessible fields in the parent field Query query = new Query('Account'). selectAllFields('Owner'); ","srcFilePath":"src/pages/docs/Query/field.md","id":"field","location":"/docs/Query/field.html","url":"/query-apex/docs/Query/field.html"},"result":{"title":"Result","description":"Methods to get the Query result","layout":"guide","icon":"code-file","weight":2,"content":" {$page.description} run Run the query as if running Database.query(). public List\\ run() Returns a list of SObject. Alias to toSObjectList(). List accounts = new Query('Account'). run(); fetch Fetch a subset of the result. public SObject fetch() Fetch the first SObject from the result. Returns an SObject. Account account = (Account) new Query('Account'). fetch(); public SObject fetch(Integer n) Fetch the n elements from the result. n: Indicates the number of elements. Returns an SObject. Account account = (Account) new Query('Account'). fetch(2); public List\\ fetch(Integer first, Integer last) Fetch a subset of result in the range [first, last). Returns a list of SObject. List accounts = new Query('Account'). fetch(2, 4); toSObjectList Run the query as if running Database.query(). public List\\ toSObjectList() Returns a list of SObject. Alias to run(). List accounts = new Query('Account'). toSObjectList(); toIdList Run the query and return the Id list of the result. public List\\ toIdList() Returns a list of Id. List accounts = new Query('Account'). toIdList(); getQueryLocator Get the QueryLocator that can be used for Batch Apex. public Database.QueryLocator getQueryLocator() Returns a Database.QueryLocator. Database.QueryLocator locator = new Query('Account'). selectAllFields(). getQueryLocator(); aggregate Get the result of the aggregated query. Can only be used with aggregate functions. public List\\ aggregate() Get the result of the aggregated query. Returns a List of AggregateResult. The returned list is guaranteed to be non-empty. List result = new Query('Account'). count('Name'). aggregate(); toQueryString Get an executable SOQL string that can be used in Dateabase.query(). public String toQueryString() Returns an executable SOQL string. String queryStr = new Query('Account'). selectAllFields(). run(); List accounts = Datebase.query(queryStr); ","srcFilePath":"src/pages/docs/Query/result.md","id":"result","location":"/docs/Query/result.html","url":"/query-apex/docs/Query/result.html"},"subquery":{"title":"Subquery","description":"Subquery methods in Query","layout":"guide","icon":"code-file","weight":5,"content":" {$page.description} addSubquery Add a subquery to the query, selecting an SObject list from a specific child relationship. For example, in this query, the expression enclosed in parentheses is a subquery: SELECT Name, (SELECT LastName FROM Contacts) FROM Account public Query addSubquery(String relationshipName) relationshipName: Name of the child relationship Query q = new Query('Account'). addSubquery('Contacts'); public Query addSubquery(String relationshipName, String fields) relationshipName: Name of the child relationship fields: One or more field names in the child relationship that will be selected. If there are more than one field, they will be separated by a comma ','. Query q = new Query('Account'). addSubquery('Contacts', 'FirstName, LastName'). addSubquery('Notes', 'Title'); public Query addSubquery(String relationshipName, Set\\ fieldSet) relationshipName: Name of the child relationship fieldSet: A set of field names in the child relationship that will be selected Query q = new Query('Account'). addSubquery('Contacts', new Set{'FirstName', 'LastName'}); public Query addSubquery(String relationshipName, List\\ fieldList) relationshipName: Name of the child relationship fieldList: A list of field names in the child relationship that will be selected Query q = new Query('Account'). addSubquery('Contacts', new List{'FirstName', 'LastName'}); public Query addSubquery(Query subquery) subquery: A subquery instance constructed by the static method Query.subquery Query q = new Query('Account'). addSubquery(Query.subquery('Contacts')); subquery Creates a subquery instance. The instance can be linked to the main query using the addSubquery method afterwards. public static Query subquery(String relationshipName) relationshipName: Name of the child relationship Query q = new Query('Account'). addSubquery(Query.subquery('Contacts')); ","srcFilePath":"src/pages/docs/Query/subquery.md","id":"subquery","location":"/docs/Query/subquery.html","url":"/query-apex/docs/Query/subquery.html"}},"title":"Query class","description":"Public methods in Query","layout":"guide","icon":"code-file","weight":1,"content":" {$page.description} Query Reference Here is the reference of the public methods in Query. Every public method in Query class that returns a Query type is mutable and chainable. ","srcFilePath":"src/pages/docs/Query/index.md","id":"Query","location":"/docs/Query/","url":"/query-apex/docs/Query/","childIds":["constructors","result","field","condition","subquery","aggregate"]}},"childIds":["Query","search"]},"tutorials":{"title":"Tutorials","description":"The tutorials","url":"/query-apex/tutorials/getting_started/step_1.html","layout":false,"content":" ","srcFilePath":"src/pages/tutorials/index.soy","id":"tutorials","location":"/tutorials/","customURL":true,"children":{"getting_started":{"title":"Getting Started","description":"The Getting Started Tutorial","tutorialTitle":"Getting started with Query.apex","url":"/query-apex/tutorials/getting_started/step_1.html","layout":false,"content":" ","srcFilePath":"src/pages/tutorials/getting_started/index.soy","id":"getting_started","location":"/tutorials/getting_started/","customURL":true,"children":{"step_1":{"title":"Installation","description":"Include Apex files","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":1,"content":" {$page.title} Include Query.cls and QueryTest.cls (optional) into your Org, and you are ready to go. ","srcFilePath":"src/pages/tutorials/getting_started/step_1.md","id":"step_1","location":"/tutorials/getting_started/step_1.html","url":"/query-apex/tutorials/getting_started/step_1.html"},"step_10":{"title":"Aggregate Functions Part 2","description":"Construct aggregate functions with group by clauses","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":120,"weight":10,"content":" {$page.title} Aggregate functions are more useful combined with the 'groupBy' method, so that each group can have its own aggregate result. Similar to the simple aggregate functions, the 'aggregate' method is needed to get the aggregate results, which will return a list of 'AggregateResult' items. List results = new Query('Account'). selectField('Rating'). count('Name', 'countName'). max('NumberOfEmployees', 'maxEmployees'). groupBy('Rating'). aggregate(); This example tries to group the accounts based on their rating, and for each rating group it tries to find the maximum number of employees. for (AggregateResult result : results) { System.debug('Rating: ' + result.get('Rating')); System.debug('maxEmployees: ' + result.get('maxEmployees')); } Note that we can only select fields that appear in the group by method. In this example, only the 'Rating' field appears in the group by clause, so only the 'Rating' field can be selected. ","srcFilePath":"src/pages/tutorials/getting_started/step_10.md","id":"step_10","location":"/tutorials/getting_started/step_10.html","url":"/query-apex/tutorials/getting_started/step_10.html"},"step_11":{"title":"Aggregate Functions Part 3","description":"Construct aggregate functions with having clauses","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":120,"weight":11,"content":" {$page.title} With HAVING clauses, aggregate functions can be even more powerful. See this example: Suppose we have a parent object Account, and a child object Opportunity, I want to query all the Accounts with at least one Opportunity. If we use child relationship query (subquery), we might still get all the Accounts, with some of them having the Opportunity child as an empty list. And then we need to do the filter manually, removing the Accounts with empty Opportunity list. Apparently, such way costs unnecessary memory. But we can actually do it in one query, using GROUP BY and HAVING clauses. List results = new Query('Opportunity'). selectField('AccountId'). count('Name', 'countName'). groupBy('AccountId'). addHaving(Query.conditionGe('Count(Name)', 1)). aggregate(); // Loop the aggregate result to get the account ids List accountIds = new List(); for (AggregateResult result : results) { accountIds.add((Id)result.get('AccountId')); } ","srcFilePath":"src/pages/tutorials/getting_started/step_11.md","id":"step_11","location":"/tutorials/getting_started/step_11.html","url":"/query-apex/tutorials/getting_started/step_11.html"},"step_2":{"title":"Simple queries","description":"Some simple queries","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":2,"content":" {$page.title} Lets start with a simplest query: querying all Account records: List accounts = new Query('Account').run(); The 'run' method executes the query and returns the type 'List&lt;SObject&gt;'. This is equivalent to this statement, selecting only the ID field in the Account records. List accounts = [ SELECT Id FROM Account ]; We can now move further by querying an Account record with a specific Id, which is quite an common case in development. Account account = (Account)new Query('Account'). byId('0010l00000QJN3MAAX'). fetch(); The 'byId' method limits the result with a specific Id. The 'fetch' method executes the query and returns the first record in the result. The statement is equivalent to: Account account = [ SELECT Id FROM Account WHERE Id = '0010l00000QJN3MAAX' ]; That's our first tutorial of Query.apex. We just learned to build a simple query from Query.apex. ","srcFilePath":"src/pages/tutorials/getting_started/step_2.md","id":"step_2","location":"/tutorials/getting_started/step_2.html","url":"/query-apex/tutorials/getting_started/step_2.html"},"step_3":{"title":"Fields Selection","description":"Select specific fields","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":3,"content":" {$page.title} By default Query.apex will select only the Id field in the SObject, however we can override this if we want to select other fields. For example, this query will only select only the Name field from the Account object. List accounts = new Query('Account').selectFields('Name').run(); This is equivalent to: List accounts = [ SELECT Name FROM Account ]; We can also call 'selectFields' method multiple times, the result is additive: List accounts = new Query('Account'). selectFields('Name'). selectFields('Phone'). selectFields('Website'). selectFields('Description'). run(); That's equivalent to: List accounts = [ SELECT Name, Phone, Website, Description FROM Account ]; Alternatively, we can put all the fields in one 'selectFields' method, still preserving the additivity: List accounts = new Query('Account'). selectFields('Name, Phone, Website'). selectFields('Description'). run(); Compare with: List fields = new List{'Name', 'Phone', 'Website'}; List accounts = new Query('Account'). selectFields(fields). selectFields('Description'). run(); or: Set fields = new Set{'Name', 'Phone', 'Website'}; List accounts = new Query('Account'). selectFields(fields). selectFields('Description'). run(); To make user convenient, Query.apex provides the 'selectAllFields' method to select all user accessible fields: List accounts = new Query('Account'). selectAllFields(). run(); ","srcFilePath":"src/pages/tutorials/getting_started/step_3.md","id":"step_3","location":"/tutorials/getting_started/step_3.html","url":"/query-apex/tutorials/getting_started/step_3.html"},"step_4":{"title":"Fields Selection Continued","description":"Select parental fields","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":4,"content":" {$page.title} It's also possible to include fields from a parent. The easiest way would be passing the parent name to the 'selectAllFields' method: List accounts = new Query('Account'). selectAllFields('Owner'). run(); This would select the Id field in Account object, as weel as all the user accessible fields in the Owner reference, which is a User object. The statement is equivalent to: List accounts = [ SELECT Id, Owner.Id, Owner.Name, Owner.CreatedById ... FROM Account ]; Another way would be simply passing the parent field along with the relationship to the 'selectFields' method: List accounts = new Query('Account'). selectFields('Owner.Name, Owner.CreatedById'). run(); equivalent to: List accounts = [ SELECT Id, Owner.Name, Owner.CreatedById FROM Account ]; Meanwhile, multiple layer parent relationship is supported: List accounts = new Query('Contact'). selectFields('Account.Owner.Name'). run(); ","srcFilePath":"src/pages/tutorials/getting_started/step_4.md","id":"step_4","location":"/tutorials/getting_started/step_4.html","url":"/query-apex/tutorials/getting_started/step_4.html"},"step_5":{"title":"Conditions","description":"Add one condition to the query","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":150,"weight":5,"content":" {$page.title} Most of the time, we want to make a query with conditions, typically querying a record with a specific Id or a lookup field, then we can use the 'addConditionEq' method: Account account = (Account)new Query('Account'). addConditionEq('Id', '0010l00000QJN3MAAX'). fetch(); This statement is querying an Account record with Id '0010l00000QJN3MAAX', equivalent to this statement: Account account = [ SELECT Id FROM Account WHERE Id = '0010l00000QJN3MAAX' ]; In previous tutorials we saw another statement which has the same functionality, using the 'byId' method: Account account = (Account)new Query('Account'). byId('0010l00000QJN3MAAX'). fetch(); Now let's try querying the accounts owned by the current user: List accounts = new Query('Account'). addConditionEq('OwnerId', UserInfo.getUserId()). run(); equivalent to: List accounts = [ SELECT Id FROM Account WHERE OwnerId = :UserInfo.getUserId() ]; 'addConditionEq(String field, Object arg)' is limiting the query with a field equals to the variable 'arg', while Query.apex provides other operators for conditions, including 'addConditionNotEq', 'addConditionIn', 'addConditionNotIn', 'addConditionLt', 'addConditionLe', 'addConditionGt', 'addConditionGe' and 'addConditionLike'. Examples are: new Query('Account'). addConditionNotEq('Name', 'N/A'). run(); new Query('Account'). addConditionIn('Name', new Set{'ABC'}). run(); new Query('Account'). addConditionNotIn('Name', new Set{'N/A'}). run(); new Query('Account'). addConditionLt('NumberOfEmployees', 15). run(); new Query('Account'). addConditionLe('NumberOfEmployees', 10). run(); new Query('Account'). addConditionGt('NumberOfEmployees', 5). run(); new Query('Account'). addConditionGe('NumberOfEmployees', 10). run(); new Query('Account'). addConditionLike('Name', '%ABC%'). run(); ","srcFilePath":"src/pages/tutorials/getting_started/step_5.md","id":"step_5","location":"/tutorials/getting_started/step_5.html","url":"/query-apex/tutorials/getting_started/step_5.html"},"step_6":{"title":"Conditions Part 2","description":"Add multiple conditions","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":6,"content":" {$page.title} In the previous section, we have learned to add a single condition to the query. In many cases, however, that is far from enough. So Query.apex allows calling 'addConditionXX' multiple times, resulting in combining all the conditions with boolean 'and' operation. Example: List accounts = new Query('Account'). addConditionEq('Name', 'Sam'). addConditionGt('NumberOfEmployees', 0). addConditionIn('Phone', new Set{'+61 400 000 000'}). run(); equivalent to: List accounts = [ SELECT Id FROM Account WHERE Name = 'Sam' AND NumberOfEmployees 0 AND Phone IN :new Set{'+61 400 000 000'} ]; Meanwhile, Query.apex provides a method 'switchToDisjunction' to change the boolean 'and' operator to the boolean 'or' operator. Appending an extra 'switchToDisjunction' method to the same example above: List accounts = new Query('Account'). addConditionEq('Name', 'Sam'). addConditionGt('NumberOfEmployees', 0). addConditionIn('Phone', new Set{'+61 400 000 000'}). switchToDisjunction(). run(); equivalent to: List accounts = [ SELECT Id FROM Account WHERE Name = 'Sam' OR NumberOfEmployees 0 OR Phone IN :new Set{'+61 400 000 000'} ]; ","srcFilePath":"src/pages/tutorials/getting_started/step_6.md","id":"step_6","location":"/tutorials/getting_started/step_6.html","url":"/query-apex/tutorials/getting_started/step_6.html"},"step_7":{"title":"Conditions Part 3","description":"Add more complex conditions","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":180,"weight":7,"content":" {$page.title} We have learned to add multiple conditions in the previous section, but those conditions were very limited. What if we want to construct a condition with a combination of both boolean operators? In order to do that, we have to construct a 'Condition' variable, before combining these conditions with the boolean operations, followed by an 'addCondition' method to link the condition with the query. A typical example would be: List accounts = new Query('Account'). addCondition( Query.doOr( Query.conditionEq('Name', 'Sam'), Query.doAnd( Query.conditionGt('NumberOfEmployees', 0), Query.conditionIn('Phone', new Set{'+61 400 000 000'}) ) ) ). run(); This statement is equivalent to: List accounts = [ SELECT Id FROM Account WHERE Name = 'Sam' OR ( NumberOfEmployees 0 AND Phone IN :new Set{'+61 400 000 000'} ) ]; Let me explain the example step by step. 'Query.conditionXX' are a series static methods that construct a 'Condition' variable, similar to the member methods 'addCondtionXX', these include: 'conditionNotEq', 'conditionIn', 'conditionNotIn', 'conditionLt', 'conditionLe', 'conditionGt', 'conditionGe' and 'conditionLike'. Then, we can run boolean operations on any 'Condition' variables. Because the fact that 'AND' and 'OR' have been reserved keyword in apex language, we have to use 'doAnd' and 'doOr' as replacement method names. These two methods are both static methods, with 'Condition' as the return type, so that the return value can be a parameter of another boolean operation. A sample code from the example above: Query.Condition condition = Query.doAnd( Query.conditionGt('NumberOfEmployees', 0), Query.conditionIn('Phone', new Set{'+61 400 000 000'}) ); A more complicated example from above: Query.Condition condition = Query.doOr( Query.conditionEq('Name', 'Sam'), Query.doAnd( Query.conditionGt('NumberOfEmployees', 0), Query.conditionIn('Phone', new Set{'+61 400 000 000'}) ) ); It's also possible to pass up to 4 parameters in each boolean operation: Query.Condition condition = Query.doOr( Query.conditionEq('Name', 'Sam'), Query.conditionGt('NumberOfEmployees', 0), Query.conditionIn('Phone', new Set{'+61 400 000 000'}), Query.conditionEq('Email', 'sam@tarly.com') ); Once we have constructed our Condition variable, we can pass the condition to the query, using its member method 'addCondition'. Let's try a simple condition first: Query.Condition condition = Query.conditionEq('Name', 'Sam'); List accounts = new Query('Account'). addCondition(condition). run(); which is indeed equivalent to: List accounts = new Query('Account'). addConditionEq('Name', 'Sam'). run(); But this time, we can create more complicated conditions: Query.Condition condition = Query.doOr( Query.conditionEq('Name', 'Sam'), Query.doAnd( Query.conditionGt('NumberOfEmployees', 0), Query.conditionIn('Phone', new Set{'+61 400 000 000'}) ) ); List accounts = new Query('Account'). addCondition(condition). run(); or we can write it in one statement, which is identical to the first example we saw in this section. List accounts = new Query('Account'). addCondition( Query.doOr( Query.conditionEq('Name', 'Sam'), Query.doAnd( Query.conditionGt('NumberOfEmployees', 0), Query.conditionIn('Phone', new Set{'+61 400 000 000'}) ) ) ). run(); We can still call 'addConditionXX' methods and 'addCondition' simultaneously, which by default, will combine the conditions with boolean 'and' operations, unless calling the 'switchToDisjunction' method explicitly: List accounts = new Query('Account'). addCondition( Query.doOr( Query.conditionEq('Name', 'Sam'), Query.conditionGt('NumberOfEmployees', 0) ) ). addConditionIn('Phone', new Set{'+61 400 000 000'}). run(); which is equivalent to: List accounts = new Query('Account'). addCondition( Query.doAnd( Query.doOr( Query.conditionEq('Name', 'Sam'), Query.conditionGt('NumberOfEmployees', 0) ), Query.conditionIn('Phone', new Set{'+61 400 000 000'}) ) ). run(); After this section, you will be capable of creating a query with any complex conditions. ","srcFilePath":"src/pages/tutorials/getting_started/step_7.md","id":"step_7","location":"/tutorials/getting_started/step_7.html","url":"/query-apex/tutorials/getting_started/step_7.html"},"step_8":{"title":"Subqueries","description":"Querying child relationships","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":120,"weight":8,"content":" {$page.title} In this section, we will see how a child relationship query, sometimes called subquery, can be constructed. But before that, let's review how a subquery works in Salesforce: Take the objects Account and Contact as an example. Contact object has a lookup field (foreign key) pointing to a Contact, so Account is the parent of Contact, and in reverse Contact is the child of Account. We already saw that in previous sections, when querying the Contact object, it's also possible to get the fields in the parent object, which is Account object in this case. However, it would be slightly more complicated when trying to query a field from a child. Here is an example of such a query in SOQL: SELECT Name, (SELECT FirstName, LastName FROM Contacts) FROM Account In this case, 'Contacts' is the child relationship name, and the query inside the parentheses is a subquery. Let's see how to construct such a query using Query.apex: List accounts = new Query('Account'). addSubquery( Query.subquery('Contacts'). selectFields('FirstName, LastName') ). run(); Similar to the condition, we need to construct a subquery using the static method 'subquery', which takes a child relationship name as a parameter, before calling the 'addSubquery' member method. Here is another example of a subquery with conditions and limits: List accounts = new Query('Account'). addSubquery( Query.subquery('Contacts'). addConditionEq('FirstName', 'Sam'). addConditionIn('LastName', new List{'Tarly'}) ). run(); As we can see, after constructing the subquery, we can still do field selection and add conditions using the same methods in Query. Using a combination of the methods above, we should be able to build a query with a subquery in any complexity. ","srcFilePath":"src/pages/tutorials/getting_started/step_8.md","id":"step_8","location":"/tutorials/getting_started/step_8.html","url":"/query-apex/tutorials/getting_started/step_8.html"},"step_9":{"title":"Aggregate Functions Part 1","description":"Construct queries with simple aggregate functions","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":120,"weight":9,"content":" {$page.title} Query.apex now supports the powerful aggregate functions. Features include 'count', 'countDistinct', 'max', 'min', 'avg', 'sum', 'group by' clauses, and even 'having' clauses. A simple aggregate function can be: List result = new Query('Account'). max('NumberOfEmployees', 'maxEmployees'). aggregate(); Its equivalent a static SOQL looks like this: List result = [ SELECT Max(NumberOfEmployees) maxEmployees FROM Account ]; In this example, the query finds the maximum number in the NumberOfEmployees field of all available Accounts, and use 'maxEmployees' as an alias of the aggregate function. As you can see, the return type is a list of AggregateResult, which is a standard Salesforce class. Since we are not using any 'group by' clauses, we can safely assume there is one and only one element in this list. To get the result of the aggregate function we can use the alias we just set. List result = new Query('Account'). max('NumberOfEmployees', 'maxEmployee'). aggregate(); Integer maxEmployee = (Integer)result[0].get('maxEmployee'); ","srcFilePath":"src/pages/tutorials/getting_started/step_9.md","id":"step_9","location":"/tutorials/getting_started/step_9.html","url":"/query-apex/tutorials/getting_started/step_9.html"}},"childIds":["step_1","step_2","step_3","step_4","step_5","step_6","step_7","step_8","step_9","step_10","step_11"]}},"childIds":["getting_started"]}},"childIds":["docs","tutorials"]},"basePath":"/query-apex"}